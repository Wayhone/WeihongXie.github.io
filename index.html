<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Weihong Xie&#39;s Blogs</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/EileenBella.png)">
        <div class='av-pic' style="background-image: url(/assets/Bella.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Weihong Xie&#39;s Blogs</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/WeihongXie">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Knapsack/">背包问题</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.960Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>背包问题是一类经典的动态规划问题，它非常灵活，需要仔细琢磨体会，本文先对背包问题的几种常见类型作一个总结，期望可以用一套框架解决背包问题。<br>常见背包问题可分为：</p>
<h2 id="01-背包问题："><a href="#01-背包问题：" class="headerlink" title="01 背包问题："></a>01 背包问题：</h2><p>最基本的背包问题就是 <strong>01 背包问题</strong>：一共有 <code>N</code> 件物品，第 <code>i</code>（i 从 1 开始）件物品的重量为 <code>w[i]</code>，价值为 <code>v[i]</code>。在总重量不超过背包承载上限 <code>W</code> 的情况下，能够装入背包的最大价值是多少？</p>
<h2 id="完全背包问题："><a href="#完全背包问题：" class="headerlink" title="完全背包问题："></a>完全背包问题：</h2><p>完全背包与 01 背包不同就是每种物品可以有无限多个：一共有 <code>N</code> 种物品，每种物品有无限多个，第 <code>i</code>（i 从 1 开始）种物品的重量为 <code>w[i]</code>，价值为 <code>v[i]</code>。在总重量不超过背包承载上限 <code>W</code> 的情况下，能够装入背包的最大价值是多少？<br>可见 01 背包问题与完全背包问题主要区别就是<strong>物品是否可以重复选取</strong>。</p>
<h3 id="背包问题具备的特征："><a href="#背包问题具备的特征：" class="headerlink" title="背包问题具备的特征："></a>背包问题具备的特征：</h3><p>是否可以根据一个 <strong>target（直接给出或间接求出）</strong>，<strong>target</strong> 可以是数字也可以是字符串，再给定一个数组 <strong>arrs</strong>，问：能否使用 <strong>arrs</strong> 中的元素做各种排列组合得到 <strong>target</strong>。</p>
<h2 id="背包问题解法："><a href="#背包问题解法：" class="headerlink" title="背包问题解法："></a>背包问题解法：</h2><h3 id="01-背包问题：-1"><a href="#01-背包问题：-1" class="headerlink" title="01 背包问题："></a>01 背包问题：</h3><p>如果是 01 背包，即数组中的元素不可重复使用，<strong>外循环遍历 arrs，内循环遍历 target</strong>，且<strong>内循环倒序</strong>:</p>
<h3 id="完全背包问题：-1"><a href="#完全背包问题：-1" class="headerlink" title="完全背包问题："></a>完全背包问题：</h3><p>（1）如果是<strong>完全背包</strong>，即数组中的元素可重复使用并且不考虑元素之间顺序，<strong>arrs 放在外循环（保证 arrs 按顺序），target在内循环</strong>。且<strong>内循环正序</strong>。<br>（2）如果组合问题需考虑元素之间的顺序，需<strong>将 target 放在外循环，将 arrs 放在内循环</strong>，且<strong>内循环正序</strong>。</p>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h3><ol start="416">
<li>分割等和子集</li>
</ol>
<p>本题要求把数组分成两个等和的子集，相当于找到一个子集，其和为 sum / 2，这个 sum / 2 就是 target（target 间接给出）。<br>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 num: nums，内层循环为 target。  </p>
<p>dp[i] 表示是否存在和为 i 的 num 组合。  </p>
<p>外层遍历 nums 每个 num；<br>内层遍历 target（由大到小）。<br>对于元素之和等于 i - num 的每一种组合，在最后添加 num 之后即可得到一个元素之和等于 i 的组合，因此dp[i] 依赖于 dp[i - num]，并且在计算 dp[i - num] 时，要保证索引较小的元素值不被覆盖，需要后向更新 dp[i]，并且当 i - num &lt; i 时， dp[i] 已经更新过，于是：<br><code>dp[i] = dp[i] || dp[i - num]</code><br>对于特例：如果 sum 为奇数，那一定找不到符合要求的子集，返回 False。<br>对于边界条件，我们定义 dp[0] = true 表示当 i - num = 0，存在一个 num 和为 i。<br>最后返回 dp[target]。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target; i &gt;= num; i--)&#123;</span><br><span class="line">               </span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：  </p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<ol start="494">
<li>目标和</li>
</ol>
<p>我们想要的 S = 正数和 - 负数和 = x - y<br>而已知 x 与 y 的和是数组总和：x + y = sum<br>可以求出 x = (S + sum) / 2 = target<br>也就是我们要从 nums 数组里选出几个数，令其和为 target（target 间接给出）。<br>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 nums，内层循环为 target。<br>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。  </p>
<p>外层遍历 nums 每个 num；<br>内层遍历 target（由大到小）。<br>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。<br><code>dp[i] = dp[i] + dp[i - num]</code><br>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = (S + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target; i &gt;= num; i--)&#123;               </span><br><span class="line">                dp[i] = dp[i] + dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ol start="139">
<li>单词拆分</li>
</ol>
<p>转化为是否可以用 wordDict 中的词组合成 s，完全背包问题，并且为“考虑排列顺序的完全背包问题”，外层循环为 target ，内层循环为选择池 wordDict。<br>dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成。  </p>
<p>外层遍历 s 中每一个与 word 同长度的字串 s.substr(i - sz, sz) ；<br>内层遍历 wordDict 每个 word。<br>判断 s.substr(i - sz, sz) == word：<br>（1）若不相等，说明与该 word 不匹配，继续遍历；<br>（2）若相等，说明从 [i - sz] 到 i 的字符与 word 匹配。<br><code>dp[i] = dp[i] || d[[i - sz]]</code><br>对于边界条件，我们定义 dp[0] = true 表示空串且合法。<br>最后返回 dp[s.size()]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word: wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> sz = word.<span class="built_in">size</span>();        </span><br><span class="line">                <span class="keyword">if</span> (i - sz &gt;= <span class="number">0</span> &amp;&amp; s.<span class="built_in">substr</span>(i - sz, sz) == word)</span><br><span class="line">                    dp[i] = dp[i] || dp[i - sz];            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<ol start="279">
<li>完全平方数<br>我们想要的 S = 若干个完全平方数的和<br>完全平方数最小为 1，最大为 sqrt(n)<br>也就是我们要从 nums = [1, 2, …, sqrt(n)] 数组里选出几个数，令其平方和为 target = n。<br>于是转化为是否可以用 nums 中的数组合和成 target，完全背包问题，外层循环为选择池 nums，内层循环为 target。<br>dp[i] 表示和为 i 的 nums 组合中完全平方数最少有 dp[i] 个。  </li>
</ol>
<p>外层遍历 nums 每个 num；<br>内层遍历 n。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="built_in">sqrt</span>(n); num++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= num * num)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - num * num] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于元素之和等于 i - num * num 的每一种组合，在最后添加 num 之后即可得到一个元素平方和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − num * num] + 1 中的最小值。<br><code>dp[i] = min(dp[i], dp[i - num * num] + 1)</code><br>对于边界条件，我们定义 dp[0] = 0。<br>最后返回 dp[n]  </p>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n x sqrt{n})，在主步骤中，我们有一个嵌套循环，其中外部循环是 n 次迭代，而内部循环最多需要 sqrt{n} 迭代。</li>
<li>空间复杂度：O(n)，使用了一个一维数组 dp。</li>
</ul>
<ol start="322">
<li>零钱兑换</li>
</ol>
<p>转化为是否可以用 coins 中的数组合和成 amount，完全背包问题，并且为“不考虑排列顺序的完全背包问题”，外层循环为选择池 coins，内层循环为 amount。<br>dp[i] 表示和为 i 的 coin 组合中硬币最少有 dp[i] 个。  </p>
<p>外层遍历 coins 每个 coin；<br>内层遍历 amount。<br>对于元素之和等于 i - coin 的每一种组合，在最后添加 coin 之后即可得到一个元素之和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − coin] + 1 中的最小值。<br><code>dp[i] = min(dp[i], dp[i - coin] + 1)</code><br>对于边界条件，我们定义 dp[0] = 0。<br>最后返回 dp[amount]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;      </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(amount x n)，其中 n 为 coins 大小</li>
<li>空间复杂度：O(amount)</li>
</ul>
<ol start="377">
<li>组合总和 Ⅳ</li>
</ol>
<p>转化为是否可以用 nums 中的数组合和成 target，完全背包问题，并且为“考虑排列顺序的完全背包问题”，外层循环为 target ，内层循环为选择池 nums。<br>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。  </p>
<p>外层遍历 target；<br>内层遍历 nums 每个 num。<br>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。<br><code>dp[i] = dp[i] + dp[i - num]</code><br>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i])</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(target x n)，其中 n 为 wordDict 大小</li>
<li>空间复杂度：O(target)</li>
</ul>
<ol start="518">
<li>零钱兑换 II</li>
</ol>
<p>转化为是否可以用 coins 中的数组合和成 amount，完全背包问题，并且为“不考虑排列顺序的完全背包问题”，外层循环为选择池 coins，内层循环为 amount。<br>dp[i] 表示和为 i 的 coin 组合有 dp[i] 种。  </p>
<p>外层遍历 coins 每个 coin；<br>内层遍历 amount。<br>对于元素之和等于 i - coin 的每一种组合，在最后添加 coin 之后即可得到一个元素之和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − coin] 之和。<br><code>dp[i] = dp[i] + dp[i - coin]</code><br>对于边界条件，我们定义 dp[0] = 1，表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[amount]。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                    dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(amount x n)，其中 n 为 coins 大小</li>
<li>空间复杂度：O(amount)</li>
</ul>
<p>作者：wulafly-2<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-p9saf/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-p9saf/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Leetcode-Note/">Leetcode Note</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.956Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a><strong>Data Structure</strong></h2><h3 id="1-Vector-向量"><a href="#1-Vector-向量" class="headerlink" title="1. Vector 向量"></a>1. Vector 向量</h3><p><strong>特性</strong></p>
<ul>
<li>顺序序列</li>
<li>动态数组</li>
</ul>
<p><strong>基本函数</strong><br>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>()</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> nSize)</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> nSize, <span class="keyword">const</span> t&amp; t) 全是t的vector</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>增删查改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="comment">// 删除最后一个 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="comment">// 首元素</span></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="comment">// 末元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="comment">// 向量头指针</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="comment">// 向量尾指针</span></span></span><br><span class="line"><span class="function"><span class="comment">// 其他</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-Queue-队列"><a href="#2-Queue-队列" class="headerlink" title="2. Queue 队列"></a>2. Queue 队列</h3><p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue&lt;<span class="keyword">const</span> value_type&amp;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增删查改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增删查改</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>; <span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> string&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Leetcode-Daily/">Record of daily Leetcode</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.951Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>刷题技巧：<br>数据结构的基本存储方式：链式，顺序；<br>数据结构的操作方式：增删查改；<br>数据结构的遍历方式：迭代，递归  </p>
<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a><strong>Binary Tree</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// inorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// postorder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版本，使用Stack存储节点</span></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; current-&gt;val;</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right) </span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (current <span class="keyword">or</span> !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(current);</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 栈顶元素是最左节点</span></span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">        current = stack.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目：</p>
<ul>
<li><strong>102_medium: level order</strong></li>
<li><strong>103_medium: zigzag level order</strong></li>
<li><strong>105_medium: pre&amp;in construct</strong></li>
<li><strong>106_medium: in&amp;post construct</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102 level order</span></span><br><span class="line"><span class="comment">// 使用队列FIFO的特性实现层次遍历，每次push队首的左右子节点，pop</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; layer_seq;</span><br><span class="line">        layer_seq.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; root_seq = <span class="built_in">vector</span>(<span class="number">1</span>, root-&gt;val);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root_seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!layer_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node_num = layer_seq.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node_num; i++) &#123;                </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;left) &#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;left-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;right)&#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;right-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                layer_seq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!seq.<span class="built_in">empty</span>()) </span><br><span class="line">                res.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 103 use dequeue</span></span><br></pre></td></tr></table></figure>


<p>递归问题基本可以代入为树的问题</p>
<p>Solved:</p>
<ul>
<li><strong>124_Hard: find max path using postorder</strong></li>
</ul>
<h2 id="关于Binary-Tree的经典问题"><a href="#关于Binary-Tree的经典问题" class="headerlink" title="关于Binary Tree的经典问题"></a>关于Binary Tree的经典问题</h2><h2 id="1-最近公共祖先-LowestCommonAncestor"><a href="#1-最近公共祖先-LowestCommonAncestor" class="headerlink" title="1. 最近公共祖先 LowestCommonAncestor"></a><strong>1. 最近公共祖先 LowestCommonAncestor</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="comment">// one in left tree, other in right tree</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Binary-Search-Tree"><a href="#2-Binary-Search-Tree" class="headerlink" title="2. Binary Search Tree"></a><strong>2. Binary Search Tree</strong></h2><p>二叉搜索树的中序遍历 = 树节点从小到大遍历</p>
<h2 id="3-Balanced-Binary-Tree"><a href="#3-Balanced-Binary-Tree" class="headerlink" title="3. Balanced Binary Tree"></a><strong>3. Balanced Binary Tree</strong></h2><hr>
<h2 id="Dynamic-Programming-动态规划"><a href="#Dynamic-Programming-动态规划" class="headerlink" title="Dynamic Programming 动态规划"></a><strong>Dynamic Programming 动态规划</strong></h2><p>动态规划相比于暴力穷举/回溯算法，消除了重叠子问题，因此更快。可以看作是穷举+剪枝的结合。（通过哈希表作为备忘录，也可以消除重叠子问题的计算）</p>
<p>动态规划的三个特点：</p>
<ul>
<li>求最值；</li>
<li>求子问题的最值（-&gt;状态转移）；</li>
<li>存在重叠子问题；</li>
</ul>
<p>做题思路：</p>
<ol>
<li>问题的最简单情况base case是什么？</li>
<li>问题一共有什么状态？</li>
<li>每个状态可以做出什么选择？</li>
<li>如何定义函数来表现状态和选择？</li>
</ol>
<p>动态规划是“自下而上”的。从最简单、规模最小的问题如<code>f(1),f(2)</code>往上推。一般是由循环迭代完成计算的。</p>
<p><strong>基本的DP思路</strong></p>
<ol>
<li>定义<code>dp[i][j]</code>的含义，一般<code>dp[M][N]</code>会是题目所求的答案。同时注意dp的边界问题；</li>
<li>定义Base Case。 一般是<code>dp[0][0]</code>或者是<code>dp[0][...], dp[...][0]</code>；</li>
<li>寻找<code>dp[i][j]</code>的状态转移方程。 考虑一下到达<code>dp[i][j]</code>的上一步操作是什么，一般从<code>dp[i][j-1], dp[i-1][j], dp[i-1][j-1]</code>入手。</li>
</ol>
<p>进阶思路：</p>
<ol>
<li>最优子结构性值作为动态规划问题的必要条件，一定是求最值；</li>
<li>dp数组的遍历方向。有时是正向遍历，有时是反向遍历，有时是斜向遍历。<strong>遍历过程中，所需的状态是必须已经计算出来的；而且遍历终点必须是存储结果的位置</strong>。典型例子：Dungeon Game 反向遍历。</li>
</ol>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>将问题分到以下一类动态规划问题中：</p>
<ol>
<li>0-1 Knapsack 选/不选</li>
<li>Unbounded Knapsack 完全背包 不限数量的选/不选</li>
<li>Shortest Path (eg: Unique Paths I/II) 二维矩阵路径选择</li>
<li>Fibonacci Sequence (eg: House Thief, Jump Game) 一维矩阵，每个元素由前面元素决定</li>
<li>Longest Common Substring/Subsequence 双数组/字符串的比较</li>
</ol>
<h3 id="经典动态规划：01背包问题"><a href="#经典动态规划：01背包问题" class="headerlink" title="经典动态规划：01背包问题"></a><strong>经典动态规划：01背包问题</strong></h3><p>一个可装载重量<code>W</code>的背包，一共有<code>N</code>个物品，每个物品有重量<code>wt[i]</code>和价值<code>val[i]</code>两个属性。物品不可以分割，要么选择，要么不选择，称为01背包问题。这类问题没有排序之类的方法，只能穷举所有可能。</p>
<p>定义<code>dp[i][w]</code>：对于前<code>i</code>个物品，当前背包容量为<code>w</code>，对应的最大价值。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt;&amp; weight, vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - weight[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - weight[i]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w])；</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Backtracking-回溯算法"><a href="#Backtracking-回溯算法" class="headerlink" title="Backtracking 回溯算法"></a><strong>Backtracking 回溯算法</strong></h2><p>回溯，既纯暴力穷举，复杂度很高。如同多叉树的前序遍历/后序遍历。</p>
<p>思路：</p>
<ol>
<li>路径：已经做出的选择；</li>
<li>选择列表：当前可以做的选择；</li>
<li>结束条件：到达决策树底层的条件。</li>
</ol>
<p>核心：for循环里进行递归，递归前“做选择”，递归结束后“撤回选择”，直到结束。</p>
<p>算法框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">path, choices</span>):</span></span><br><span class="line">    <span class="keyword">if</span> condition_satisfied:</span><br><span class="line">        result.add(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        makeChoice(choice);</span><br><span class="line">        backtrack(path, choices);</span><br><span class="line">        backdrawChoice(choice);</span><br></pre></td></tr></table></figure>

<p>See <strong>N Queens</strong></p>
<hr>
<h2 id="Breath-First-Search-广度优先算法"><a href="#Breath-First-Search-广度优先算法" class="headerlink" title="Breath First Search 广度优先算法"></a><strong>Breath First Search 广度优先算法</strong></h2><p>DFS(Depth First Search)深度优先搜索算法可以被认为回溯算法。</p>
<p>BFS和DFS最大差别：<strong>BFS找到的路径一定最短，但是代价是空间复杂度比DFS大很多。</strong></p>
<p>BFS问题本质：在图中找到从起点<code>start</code>到终点<code>target</code>的最短距离。比如走迷宫、二叉树最小高度。</p>
<p>算法框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(TreeNode start, TreeNode target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q;</span><br><span class="line">    Set&lt;TreeNode&gt; visited;  <span class="comment">// 已经过的路径</span></span><br><span class="line"></span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">// 判断是否终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 加入之后的选择路径</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode x: cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bidirectional-BFS-双向BFS"><a href="#Bidirectional-BFS-双向BFS" class="headerlink" title="Bidirectional BFS 双向BFS"></a><strong>Bidirectional BFS 双向BFS</strong></h3><p>从起点<code>start</code>和终点<code>target</code>同时出发遍历。<br>不再使用队列<code>queue</code>作为主要数据结构，而是使用<code>unordered_set</code>方便、快速地判断两个集合是否有交集。<br><strong>Leetcode: WordLadder I &amp;&amp; II</strong></p>
<hr>
<h2 id="Two-Pointer-双指针"><a href="#Two-Pointer-双指针" class="headerlink" title="Two Pointer 双指针"></a><strong>Two Pointer 双指针</strong></h2><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h3><p>常用于链表之中，如</p>
<ol>
<li><strong>链表中存在环的问题</strong>（fast=-&gt;next-&gt;next, slow=-&gt;next）；</li>
<li><strong>查找链表中点</strong>（fast到头时返回slow）</li>
<li><strong>寻找链表中倒数第K元素</strong>；</li>
</ol>
<h3 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h3><p>常用于数组之中。一般初始化为<code>left = 0</code>，<code>right = len - 1</code>。</p>
<p>应用：</p>
<ol>
<li><strong>二分搜索 Binary Search</strong></li>
<li><strong>滑动窗口 Sliding Window</strong>，解决字符串匹配问题</li>
</ol>
<hr>
<h2 id="Binary-Search-二分搜索"><a href="#Binary-Search-二分搜索" class="headerlink" title="Binary Search 二分搜索"></a><strong>Binary Search 二分搜索</strong></h2><p>细节难点：mid+1还是mid-1，while用&lt;=还是&lt;等。<br>技巧：使用if的时候不要使用else，将所用情况用else if写清楚。 </p>
<p><strong>基本二分搜索：在递增序列中，寻找一个数字</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定循环终止条件<br><code>left &lt;= right</code>的终止条件是<code>left &gt; right</code>即<code>left == right + 1</code>。将整个区间[left, right]搜索完毕。</li>
<li><code>left</code>,<code>right</code>的变更形式<br>当搜索区间[left, right]的时候，如果<code>mid</code>不符合<code>target</code>条件，下一步应该考虑区间要不要包含mid，不需要则是<code>mid+1/mid-1</code>，需要则是<code>mid</code></li>
</ol>
<p><strong>带左边界的二分搜索</strong><br>终止条件：<code>left == right + 1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 继续往左;右边界：left = mid + 1;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (right &lt; 0 || nums[right] != target)</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    return right;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a><strong>Sliding Window 滑动窗口</strong></h2><p>框架  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: t)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// Expand the window</span></span><br><span class="line">        <span class="built_in">window</span>(s[right])++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">valid</span>(window, need)) &#123;</span><br><span class="line">            <span class="comment">// Narrow the window</span></span><br><span class="line">            <span class="built_in">window</span>(s[left])--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Union-Find-并查集"><a href="#Union-Find-并查集" class="headerlink" title="Union Find 并查集"></a><strong>Union Find 并查集</strong></h2><p>并查集算法，主要是解决图论中<strong>动态连通性</strong>的问题。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">// 用于调整树的高度，避免头重脚轻(不重要)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.<span class="built_in">push_back</span>(i);</span><br><span class="line">            size.<span class="built_in">push_back</span>(i); <span class="comment">// each tree is initialized with size 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x])</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rooti = <span class="built_in">find</span>(i), rootj = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (rooti == rootj)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// or simply parent[rooti] = rootj;</span></span><br><span class="line">        <span class="keyword">if</span> (size[rooti] &lt; size[rootj]) &#123;</span><br><span class="line">            parent[rooti] =  rootj;</span><br><span class="line">            size[rootj] += size[rooti];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootj] =  rooti;</span><br><span class="line">            size[rooti] += size[rootj];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>练习  </p>
<ul>
<li>「力扣」第 547 题：省份数量（中等）；</li>
<li>「力扣」第 684 题：冗余连接（中等）；</li>
<li>「力扣」第 1319 题：连通网络的操作次数（中等）；</li>
<li>「力扣」第 1631 题：最小体力消耗路径（中等）； <strong>思路</strong></li>
<li>「力扣」第 959 题：由斜杠划分区域（中等）；</li>
<li>「力扣」第 1202 题：交换字符串中的元素（中等）；</li>
<li>「力扣」第 947 题：移除最多的同行或同列石头（中等）；</li>
<li>「力扣」第 721 题：账户合并（中等）；</li>
<li>「力扣」第 803 题：打砖块（困难）；</li>
<li>「力扣」第 1579 题：保证图可完全遍历（困难）;</li>
<li>「力扣」第 778 题：水位上升的泳池中游泳（困难）。</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/06/hello-world/">Hello World</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T15:59:20.467Z" itemprop="datePublished">
    2021-07-06
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2021 - Weihong Xie </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>