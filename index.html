<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Weihong Xie&#39;s Blogs</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/bg.jpg)">
        <div class='av-pic' style="background-image: url(/assets/Bella.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Weihong Xie&#39;s Blogs</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/WeihongXie">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/12/BinaryTree/">BinaryTree</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-12T09:50:19.000Z" itemprop="datePublished">
    2021-07-12
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/Tree-Binary-Tree/">Tree, Binary Tree</a> }
  </li>


  </ul>
  
  
</div>

    </header>
    <div>
      
        <h1 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h1><h2 id="1-Traverse"><a href="#1-Traverse" class="headerlink" title="1. Traverse"></a>1. Traverse</h2><p>二叉树最基本的问题就是遍历。二叉树的常考算法本质上都是树的遍历问题。比如后序遍历求最大路径和、最近公共祖先等。</p>
<p><strong>基本的递归框架</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// inorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// postorder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代实现</strong></p>
<p>迭代版本的遍历需要<strong>使用Stack来存储树节点</strong>。最简单的是先序遍历，只需要每个节点出栈、右左子节点压栈即可。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* node;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中后序遍历的迭代，由于存在子节点-&gt;父节点的顺序，要考虑节点本身重复进栈的问题。  </p>
<p>中序遍历思路：当前节点非空，则入栈并遍历其左节点；否则栈顶（最近未遍历的父节点）出栈，栈顶节点的右节点入栈。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;    </span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node <span class="keyword">or</span> !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">nullptr</span>) &#123;                </span><br><span class="line">            s.<span class="built_in">push</span>(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">            node = s.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序遍历思路：可以用变量<code>pre</code>来标记左右节点是否已经遍历过。（或者前序遍历略作修改（先左后右），再逆序。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">    TreeNode *node, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> ((!node-&gt;right &amp;&amp; !node-&gt;left) || </span><br><span class="line">            (pre &amp;&amp; (pre == node-&gt;left || pre == node-&gt;right))) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Level Order 层次遍历</strong> </p>
<p><strong>使用<code>queue</code>存储树节点</strong>，每次遍历一层。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a>  方向标记+双向队列<code>deque</code>/预先分配数组大小<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a>  先计算树的高度，预分配数组大小再遍历  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; layer;</span><br><span class="line">    layer.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!layer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> node_num = layer.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; seq = <span class="built_in">vector</span>(node_num, <span class="number">0</span>);        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node_num; i++) &#123;</span><br><span class="line">            TreeNode *node = layer.<span class="built_in">front</span>();</span><br><span class="line">            seq[i] = node-&gt;val;                            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) layer.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) layer.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            layer.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span> (!seq.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(seq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Depth-First-Search-amp-Breath-First-Search"><a href="#2-Depth-First-Search-amp-Breath-First-Search" class="headerlink" title="2. Depth First Search &amp; Breath First Search"></a>2. Depth First Search &amp; Breath First Search</h2><p>BFS一般是寻找最短路径、树的最小高度等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span class="keyword">return</span> depth;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS一般是寻找满足特定条件的路径。一般套用后序遍历的框架。<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">129. Sum Root to Leaf Numbers</a><br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum / Hard</a></p>
<hr>
<h2 id="3-Binary-Search-Tree"><a href="#3-Binary-Search-Tree" class="headerlink" title="3. Binary Search Tree"></a>3. Binary Search Tree</h2><p>Binary Search Tree, BST 二叉搜索树，任意节点的值大于等于左子树所有节点的值，且小于等于右子树所有节点的值。</p>
<p><strong>查找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findInBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findInBST</span>(root.right, target)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findInBST</span>(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertInBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val) </span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// If not needed to insert</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) </span><br><span class="line">        root-&gt;right = <span class="built_in">insertInBST</span>(root.right, val)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;left =  <span class="built_in">insertInBST</span>(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong> (应该不考)<br>左右子树非空时，删除节点会导致树的结构变化。选择左子树最大或者右字数最小的节点代替父节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteInBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Modify the node is a nasty way</span></span><br><span class="line">        TreeNode* rmin = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (rmin-&gt;left)</span><br><span class="line">            rmin = rmin-&gt;left;</span><br><span class="line">        root-&gt;val = rmin-&gt;val;</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteInBST</span>(root.right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) </span><br><span class="line">        root-&gt;right = <span class="built_in">deleteInBST</span>(root.right, val)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;left =  <span class="built_in">deleteInBST</span>(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BST相关题目：<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST</a> 计算左子树的节点数目</p>
<hr>
<h2 id="4-Count-Complete-Binary-Tree’s-Nodes"><a href="#4-Count-Complete-Binary-Tree’s-Nodes" class="headerlink" title="4. Count Complete Binary Tree’s Nodes"></a>4. Count Complete Binary Tree’s Nodes</h2><p><strong>Complete Binary Tree</strong>: Every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible.<br><strong>Full Binary Tree</strong>: All nodes either have no children or 2 children.<br><strong>Perfect Binary Tree</strong>: Every level is completely filled.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode *l = root, *r = root;</span><br><span class="line">    <span class="keyword">int</span> lh = <span class="number">0</span>, rh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l) &#123; lh++; l = l-&gt;left; &#125;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123; rh++; r = r-&gt;right; &#125;    </span><br><span class="line">    <span class="keyword">if</span> (lh == rh)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, lh) - <span class="number">1</span>; <span class="comment">// full</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right); <span class="comment">// complete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-Lowest-Common-Ancestor-LCA"><a href="#5-Lowest-Common-Ancestor-LCA" class="headerlink" title="5. Lowest Common Ancestor(LCA)"></a>5. Lowest Common Ancestor(LCA)</h2><p>目标：在树中找到节点<code>p</code>和<code>q</code>的最近公共祖先。<br>三种情况：</p>
<ol>
<li><code>p</code>,<code>q</code>都在<code>root</code>中，则返回<code>root</code>;</li>
<li><code>p</code>,<code>q</code>都不在<code>root</code>中，则返回<code>nullptr</code>;</li>
<li>其中的<code>p</code>/<code>q</code>在<code>root</code>中，则返回<code>p</code>/<code>q</code>;</li>
</ol>
<p>这样的处理可以在递归时方便判断并且返回最近公共祖先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="comment">// one in left tree, other in right tree</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Serialize-and-Deserialize"><a href="#6-Serialize-and-Deserialize" class="headerlink" title="6. Serialize and Deserialize"></a>6. Serialize and Deserialize</h2><p>Preorder/Postorder/Level Order(Most used)<br>Inorder can not work, since the root cannot be determined.</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Knapsack/">背包问题</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.960Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>背包问题是一类经典的动态规划问题，它非常灵活，需要仔细琢磨体会，本文先对背包问题的几种常见类型作一个总结，期望可以用一套框架解决背包问题。<br>常见背包问题可分为：</p>
<h2 id="01-背包问题："><a href="#01-背包问题：" class="headerlink" title="01 背包问题："></a>01 背包问题：</h2><p>最基本的背包问题就是 <strong>01 背包问题</strong>：一共有 <code>N</code> 件物品，第 <code>i</code>（i 从 1 开始）件物品的重量为 <code>w[i]</code>，价值为 <code>v[i]</code>。在总重量不超过背包承载上限 <code>W</code> 的情况下，能够装入背包的最大价值是多少？</p>
<h2 id="完全背包问题："><a href="#完全背包问题：" class="headerlink" title="完全背包问题："></a>完全背包问题：</h2><p>完全背包与 01 背包不同就是每种物品可以有无限多个：一共有 <code>N</code> 种物品，每种物品有无限多个，第 <code>i</code>（i 从 1 开始）种物品的重量为 <code>w[i]</code>，价值为 <code>v[i]</code>。在总重量不超过背包承载上限 <code>W</code> 的情况下，能够装入背包的最大价值是多少？<br>可见 01 背包问题与完全背包问题主要区别就是<strong>物品是否可以重复选取</strong>。</p>
<h3 id="背包问题具备的特征："><a href="#背包问题具备的特征：" class="headerlink" title="背包问题具备的特征："></a>背包问题具备的特征：</h3><p>是否可以根据一个 <strong>target（直接给出或间接求出）</strong>，<strong>target</strong> 可以是数字也可以是字符串，再给定一个数组 <strong>arrs</strong>，问：能否使用 <strong>arrs</strong> 中的元素做各种排列组合得到 <strong>target</strong>。</p>
<h2 id="背包问题解法："><a href="#背包问题解法：" class="headerlink" title="背包问题解法："></a>背包问题解法：</h2><h3 id="01-背包问题：-1"><a href="#01-背包问题：-1" class="headerlink" title="01 背包问题："></a>01 背包问题：</h3><p>如果是 01 背包，即数组中的元素不可重复使用，<strong>外循环遍历 arrs，内循环遍历 target</strong>，且<strong>内循环倒序</strong>:</p>
<h3 id="完全背包问题：-1"><a href="#完全背包问题：-1" class="headerlink" title="完全背包问题："></a>完全背包问题：</h3><p>（1）如果是<strong>完全背包</strong>，即数组中的元素可重复使用并且不考虑元素之间顺序，<strong>arrs 放在外循环（保证 arrs 按顺序），target在内循环</strong>。且<strong>内循环正序</strong>。<br>（2）如果组合问题需考虑元素之间的顺序，需<strong>将 target 放在外循环，将 arrs 放在内循环</strong>，且<strong>内循环正序</strong>。</p>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h3><ol start="416">
<li>分割等和子集</li>
</ol>
<p>本题要求把数组分成两个等和的子集，相当于找到一个子集，其和为 sum / 2，这个 sum / 2 就是 target（target 间接给出）。<br>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 num: nums，内层循环为 target。  </p>
<p>dp[i] 表示是否存在和为 i 的 num 组合。  </p>
<p>外层遍历 nums 每个 num；<br>内层遍历 target（由大到小）。<br>对于元素之和等于 i - num 的每一种组合，在最后添加 num 之后即可得到一个元素之和等于 i 的组合，因此dp[i] 依赖于 dp[i - num]，并且在计算 dp[i - num] 时，要保证索引较小的元素值不被覆盖，需要后向更新 dp[i]，并且当 i - num &lt; i 时， dp[i] 已经更新过，于是：<br><code>dp[i] = dp[i] || dp[i - num]</code><br>对于特例：如果 sum 为奇数，那一定找不到符合要求的子集，返回 False。<br>对于边界条件，我们定义 dp[0] = true 表示当 i - num = 0，存在一个 num 和为 i。<br>最后返回 dp[target]。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target; i &gt;= num; i--)&#123;</span><br><span class="line">               </span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：  </p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<ol start="494">
<li>目标和</li>
</ol>
<p>我们想要的 S = 正数和 - 负数和 = x - y<br>而已知 x 与 y 的和是数组总和：x + y = sum<br>可以求出 x = (S + sum) / 2 = target<br>也就是我们要从 nums 数组里选出几个数，令其和为 target（target 间接给出）。<br>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 nums，内层循环为 target。<br>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。  </p>
<p>外层遍历 nums 每个 num；<br>内层遍历 target（由大到小）。<br>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。<br><code>dp[i] = dp[i] + dp[i - num]</code><br>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) sum += num;</span><br><span class="line">        <span class="keyword">if</span>(S &gt; sum || (S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = (S + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = target; i &gt;= num; i--)&#123;               </span><br><span class="line">                dp[i] = dp[i] + dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ol start="139">
<li>单词拆分</li>
</ol>
<p>转化为是否可以用 wordDict 中的词组合成 s，完全背包问题，并且为“考虑排列顺序的完全背包问题”，外层循环为 target ，内层循环为选择池 wordDict。<br>dp[i] 表示以 i 结尾的字符串是否可以被 wordDict 中组合而成。  </p>
<p>外层遍历 s 中每一个与 word 同长度的字串 s.substr(i - sz, sz) ；<br>内层遍历 wordDict 每个 word。<br>判断 s.substr(i - sz, sz) == word：<br>（1）若不相等，说明与该 word 不匹配，继续遍历；<br>（2）若相等，说明从 [i - sz] 到 i 的字符与 word 匹配。<br><code>dp[i] = dp[i] || d[[i - sz]]</code><br>对于边界条件，我们定义 dp[0] = true 表示空串且合法。<br>最后返回 dp[s.size()]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word: wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> sz = word.<span class="built_in">size</span>();        </span><br><span class="line">                <span class="keyword">if</span> (i - sz &gt;= <span class="number">0</span> &amp;&amp; s.<span class="built_in">substr</span>(i - sz, sz) == word)</span><br><span class="line">                    dp[i] = dp[i] || dp[i - sz];            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(target × n)，其中 n 是数组 nums 的长度。</li>
<li>空间复杂度：O(target)。</li>
</ul>
<ol start="279">
<li>完全平方数<br>我们想要的 S = 若干个完全平方数的和<br>完全平方数最小为 1，最大为 sqrt(n)<br>也就是我们要从 nums = [1, 2, …, sqrt(n)] 数组里选出几个数，令其平方和为 target = n。<br>于是转化为是否可以用 nums 中的数组合和成 target，完全背包问题，外层循环为选择池 nums，内层循环为 target。<br>dp[i] 表示和为 i 的 nums 组合中完全平方数最少有 dp[i] 个。  </li>
</ol>
<p>外层遍历 nums 每个 num；<br>内层遍历 n。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INT_MAX)</span></span>;;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="built_in">sqrt</span>(n); num++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= num * num)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - num * num] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于元素之和等于 i - num * num 的每一种组合，在最后添加 num 之后即可得到一个元素平方和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − num * num] + 1 中的最小值。<br><code>dp[i] = min(dp[i], dp[i - num * num] + 1)</code><br>对于边界条件，我们定义 dp[0] = 0。<br>最后返回 dp[n]  </p>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n x sqrt{n})，在主步骤中，我们有一个嵌套循环，其中外部循环是 n 次迭代，而内部循环最多需要 sqrt{n} 迭代。</li>
<li>空间复杂度：O(n)，使用了一个一维数组 dp。</li>
</ul>
<ol start="322">
<li>零钱兑换</li>
</ol>
<p>转化为是否可以用 coins 中的数组合和成 amount，完全背包问题，并且为“不考虑排列顺序的完全背包问题”，外层循环为选择池 coins，内层循环为 amount。<br>dp[i] 表示和为 i 的 coin 组合中硬币最少有 dp[i] 个。  </p>
<p>外层遍历 coins 每个 coin；<br>内层遍历 amount。<br>对于元素之和等于 i - coin 的每一种组合，在最后添加 coin 之后即可得到一个元素之和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − coin] + 1 中的最小值。<br><code>dp[i] = min(dp[i], dp[i - coin] + 1)</code><br>对于边界条件，我们定义 dp[0] = 0。<br>最后返回 dp[amount]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;      </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(amount x n)，其中 n 为 coins 大小</li>
<li>空间复杂度：O(amount)</li>
</ul>
<ol start="377">
<li>组合总和 Ⅳ</li>
</ol>
<p>转化为是否可以用 nums 中的数组合和成 target，完全背包问题，并且为“考虑排列顺序的完全背包问题”，外层循环为 target ，内层循环为选择池 nums。<br>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。  </p>
<p>外层遍历 target；<br>内层遍历 nums 每个 num。<br>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。<br><code>dp[i] = dp[i] + dp[i - num]</code><br>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num: nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i &amp;&amp; dp[i - num] &lt; INT_MAX - dp[i])</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(target x n)，其中 n 为 wordDict 大小</li>
<li>空间复杂度：O(target)</li>
</ul>
<ol start="518">
<li>零钱兑换 II</li>
</ol>
<p>转化为是否可以用 coins 中的数组合和成 amount，完全背包问题，并且为“不考虑排列顺序的完全背包问题”，外层循环为选择池 coins，内层循环为 amount。<br>dp[i] 表示和为 i 的 coin 组合有 dp[i] 种。  </p>
<p>外层遍历 coins 每个 coin；<br>内层遍历 amount。<br>对于元素之和等于 i - coin 的每一种组合，在最后添加 coin 之后即可得到一个元素之和等于 i 的组合，因此在计算 dp[i] 时，应该计算所有的 dp[i − coin] 之和。<br><code>dp[i] = dp[i] + dp[i - coin]</code><br>对于边界条件，我们定义 dp[0] = 1，表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[amount]。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>&amp; coin: coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                    dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(amount x n)，其中 n 为 coins 大小</li>
<li>空间复杂度：O(amount)</li>
</ul>
<p>作者：wulafly-2<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-p9saf/">https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/yi-tao-kuang-jia-jie-jue-bei-bao-wen-ti-p9saf/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Leetcode-Note/">Leetcode Note</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.956Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <h2 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a><strong>Data Structure</strong></h2><h3 id="1-Vector-向量"><a href="#1-Vector-向量" class="headerlink" title="1. Vector 向量"></a>1. Vector 向量</h3><p><strong>特性</strong></p>
<ul>
<li>顺序序列</li>
<li>动态数组</li>
</ul>
<p><strong>基本函数</strong><br>构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>()</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> nSize)</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> nSize, <span class="keyword">const</span> t&amp; t) 全是t的vector</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>增删查改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//删</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> <span class="comment">// 删除最后一个 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 查</span></span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="comment">// 首元素</span></span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="comment">// 末元素</span></span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="comment">// 向量头指针</span></span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="comment">// 向量尾指针</span></span></span><br><span class="line"><span class="function"><span class="comment">// 其他</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-Queue-队列"><a href="#2-Queue-队列" class="headerlink" title="2. Queue 队列"></a>2. Queue 队列</h3><p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">queue&lt;<span class="keyword">const</span> value_type&amp;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增删查改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>

<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增删查改</span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span> <span class="params">(<span class="keyword">size_t</span> pos, <span class="keyword">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>; <span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> string&amp; str, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">find</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">size_t</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>


      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Leetcode-Daily/">Record of daily Leetcode</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:49:38.951Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>刷题技巧：<br>数据结构的基本存储方式：链式，顺序；<br>数据结构的操作方式：增删查改；<br>数据结构的遍历方式：迭代，递归  </p>
<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a><strong>Binary Tree</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// inorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// postorder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版本，使用Stack存储节点</span></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; current-&gt;val;</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right) </span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (current <span class="keyword">or</span> !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(current);</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 栈顶元素是最左节点</span></span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">        current = stack.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目：</p>
<ul>
<li><strong>102_medium: level order</strong></li>
<li><strong>103_medium: zigzag level order</strong></li>
<li><strong>105_medium: pre&amp;in construct</strong></li>
<li><strong>106_medium: in&amp;post construct</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102 level order</span></span><br><span class="line"><span class="comment">// 使用队列FIFO的特性实现层次遍历，每次push队首的左右子节点，pop</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; layer_seq;</span><br><span class="line">        layer_seq.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; root_seq = <span class="built_in">vector</span>(<span class="number">1</span>, root-&gt;val);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root_seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!layer_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node_num = layer_seq.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node_num; i++) &#123;                </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;left) &#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;left-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;right)&#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;right-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                layer_seq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!seq.<span class="built_in">empty</span>()) </span><br><span class="line">                res.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 103 use dequeue</span></span><br></pre></td></tr></table></figure>


<p>递归问题基本可以代入为树的问题</p>
<p>Solved:</p>
<ul>
<li><strong>124_Hard: find max path using postorder</strong></li>
</ul>
<h2 id="关于Binary-Tree的经典问题"><a href="#关于Binary-Tree的经典问题" class="headerlink" title="关于Binary Tree的经典问题"></a>关于Binary Tree的经典问题</h2><h2 id="1-最近公共祖先-LowestCommonAncestor"><a href="#1-最近公共祖先-LowestCommonAncestor" class="headerlink" title="1. 最近公共祖先 LowestCommonAncestor"></a><strong>1. 最近公共祖先 LowestCommonAncestor</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="comment">// one in left tree, other in right tree</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Binary-Search-Tree"><a href="#2-Binary-Search-Tree" class="headerlink" title="2. Binary Search Tree"></a><strong>2. Binary Search Tree</strong></h2><p>二叉搜索树的中序遍历 = 树节点从小到大遍历</p>
<h2 id="3-Balanced-Binary-Tree"><a href="#3-Balanced-Binary-Tree" class="headerlink" title="3. Balanced Binary Tree"></a><strong>3. Balanced Binary Tree</strong></h2><hr>
<h2 id="Dynamic-Programming-动态规划"><a href="#Dynamic-Programming-动态规划" class="headerlink" title="Dynamic Programming 动态规划"></a><strong>Dynamic Programming 动态规划</strong></h2><p>动态规划相比于暴力穷举/回溯算法，消除了重叠子问题，因此更快。可以看作是穷举+剪枝的结合。（通过哈希表作为备忘录，也可以消除重叠子问题的计算）</p>
<p>动态规划的三个特点：</p>
<ul>
<li>求最值；</li>
<li>求子问题的最值（-&gt;状态转移）；</li>
<li>存在重叠子问题；</li>
</ul>
<p>做题思路：</p>
<ol>
<li>问题的最简单情况base case是什么？</li>
<li>问题一共有什么状态？</li>
<li>每个状态可以做出什么选择？</li>
<li>如何定义函数来表现状态和选择？</li>
</ol>
<p>动态规划是“自下而上”的。从最简单、规模最小的问题如<code>f(1),f(2)</code>往上推。一般是由循环迭代完成计算的。</p>
<p><strong>基本的DP思路</strong></p>
<ol>
<li>定义<code>dp[i][j]</code>的含义，一般<code>dp[M][N]</code>会是题目所求的答案。同时注意dp的边界问题；</li>
<li>定义Base Case。 一般是<code>dp[0][0]</code>或者是<code>dp[0][...], dp[...][0]</code>；</li>
<li>寻找<code>dp[i][j]</code>的状态转移方程。 考虑一下到达<code>dp[i][j]</code>的上一步操作是什么，一般从<code>dp[i][j-1], dp[i-1][j], dp[i-1][j-1]</code>入手。</li>
</ol>
<p>进阶思路：</p>
<ol>
<li>最优子结构性值作为动态规划问题的必要条件，一定是求最值；</li>
<li>dp数组的遍历方向。有时是正向遍历，有时是反向遍历，有时是斜向遍历。<strong>遍历过程中，所需的状态是必须已经计算出来的；而且遍历终点必须是存储结果的位置</strong>。典型例子：Dungeon Game 反向遍历。</li>
</ol>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>将问题分到以下一类动态规划问题中：</p>
<ol>
<li>0-1 Knapsack 选/不选</li>
<li>Unbounded Knapsack 完全背包 不限数量的选/不选</li>
<li>Shortest Path (eg: Unique Paths I/II) 二维矩阵路径选择</li>
<li>Fibonacci Sequence (eg: House Thief, Jump Game) 一维矩阵，每个元素由前面元素决定</li>
<li>Longest Common Substring/Subsequence 双数组/字符串的比较</li>
</ol>
<h3 id="经典动态规划：01背包问题"><a href="#经典动态规划：01背包问题" class="headerlink" title="经典动态规划：01背包问题"></a><strong>经典动态规划：01背包问题</strong></h3><p>一个可装载重量<code>W</code>的背包，一共有<code>N</code>个物品，每个物品有重量<code>wt[i]</code>和价值<code>val[i]</code>两个属性。物品不可以分割，要么选择，要么不选择，称为01背包问题。这类问题没有排序之类的方法，只能穷举所有可能。</p>
<p>定义<code>dp[i][w]</code>：对于前<code>i</code>个物品，当前背包容量为<code>w</code>，对应的最大价值。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt;&amp; weight, vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - weight[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - weight[i]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w])；</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Backtracking-回溯算法"><a href="#Backtracking-回溯算法" class="headerlink" title="Backtracking 回溯算法"></a><strong>Backtracking 回溯算法</strong></h2><p>回溯，既纯暴力穷举，复杂度很高。如同多叉树的前序遍历/后序遍历。</p>
<p>思路：</p>
<ol>
<li>路径：已经做出的选择；</li>
<li>选择列表：当前可以做的选择；</li>
<li>结束条件：到达决策树底层的条件。</li>
</ol>
<p>核心：for循环里进行递归，递归前“做选择”，递归结束后“撤回选择”，直到结束。</p>
<p>算法框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">path, choices</span>):</span></span><br><span class="line">    <span class="keyword">if</span> condition_satisfied:</span><br><span class="line">        result.add(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        makeChoice(choice);</span><br><span class="line">        backtrack(path, choices);</span><br><span class="line">        backdrawChoice(choice);</span><br></pre></td></tr></table></figure>

<p>See <strong>N Queens</strong></p>
<hr>
<h2 id="Breath-First-Search-广度优先算法"><a href="#Breath-First-Search-广度优先算法" class="headerlink" title="Breath First Search 广度优先算法"></a><strong>Breath First Search 广度优先算法</strong></h2><p>DFS(Depth First Search)深度优先搜索算法可以被认为回溯算法。</p>
<p>BFS和DFS最大差别：<strong>BFS找到的路径一定最短，但是代价是空间复杂度比DFS大很多。</strong></p>
<p>BFS问题本质：在图中找到从起点<code>start</code>到终点<code>target</code>的最短距离。比如走迷宫、二叉树最小高度。</p>
<p>算法框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(TreeNode start, TreeNode target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q;</span><br><span class="line">    Set&lt;TreeNode&gt; visited;  <span class="comment">// 已经过的路径</span></span><br><span class="line"></span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">// 判断是否终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 加入之后的选择路径</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode x: cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bidirectional-BFS-双向BFS"><a href="#Bidirectional-BFS-双向BFS" class="headerlink" title="Bidirectional BFS 双向BFS"></a><strong>Bidirectional BFS 双向BFS</strong></h3><p>从起点<code>start</code>和终点<code>target</code>同时出发遍历。<br>不再使用队列<code>queue</code>作为主要数据结构，而是使用<code>unordered_set</code>方便、快速地判断两个集合是否有交集。<br><strong>Leetcode: WordLadder I &amp;&amp; II</strong></p>
<hr>
<h2 id="Two-Pointer-双指针"><a href="#Two-Pointer-双指针" class="headerlink" title="Two Pointer 双指针"></a><strong>Two Pointer 双指针</strong></h2><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h3><p>常用于链表之中，如</p>
<ol>
<li><strong>链表中存在环的问题</strong>（fast=-&gt;next-&gt;next, slow=-&gt;next）；</li>
<li><strong>查找链表中点</strong>（fast到头时返回slow）</li>
<li><strong>寻找链表中倒数第K元素</strong>；</li>
</ol>
<h3 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h3><p>常用于数组之中。一般初始化为<code>left = 0</code>，<code>right = len - 1</code>。</p>
<p>应用：</p>
<ol>
<li><strong>二分搜索 Binary Search</strong></li>
<li><strong>滑动窗口 Sliding Window</strong>，解决字符串匹配问题</li>
</ol>
<hr>
<h2 id="Binary-Search-二分搜索"><a href="#Binary-Search-二分搜索" class="headerlink" title="Binary Search 二分搜索"></a><strong>Binary Search 二分搜索</strong></h2><p>细节难点：mid+1还是mid-1，while用&lt;=还是&lt;等。<br>技巧：使用if的时候不要使用else，将所用情况用else if写清楚。 </p>
<p><strong>基本二分搜索：在递增序列中，寻找一个数字</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定循环终止条件<br><code>left &lt;= right</code>的终止条件是<code>left &gt; right</code>即<code>left == right + 1</code>。将整个区间[left, right]搜索完毕。</li>
<li><code>left</code>,<code>right</code>的变更形式<br>当搜索区间[left, right]的时候，如果<code>mid</code>不符合<code>target</code>条件，下一步应该考虑区间要不要包含mid，不需要则是<code>mid+1/mid-1</code>，需要则是<code>mid</code></li>
</ol>
<p><strong>带左边界的二分搜索</strong><br>终止条件：<code>left == right + 1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 继续往左;右边界：left = mid + 1;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (right &lt; 0 || nums[right] != target)</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    return right;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a><strong>Sliding Window 滑动窗口</strong></h2><p>框架  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: t)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// Expand the window</span></span><br><span class="line">        <span class="built_in">window</span>(s[right])++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">valid</span>(window, need)) &#123;</span><br><span class="line">            <span class="comment">// Narrow the window</span></span><br><span class="line">            <span class="built_in">window</span>(s[left])--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Union-Find-并查集"><a href="#Union-Find-并查集" class="headerlink" title="Union Find 并查集"></a><strong>Union Find 并查集</strong></h2><p>并查集算法，主要是解决图论中<strong>动态连通性</strong>的问题。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">// 用于调整树的高度，避免头重脚轻(不重要)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.<span class="built_in">push_back</span>(i);</span><br><span class="line">            size.<span class="built_in">push_back</span>(i); <span class="comment">// each tree is initialized with size 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x])</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rooti = <span class="built_in">find</span>(i), rootj = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (rooti == rootj)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// or simply parent[rooti] = rootj;</span></span><br><span class="line">        <span class="keyword">if</span> (size[rooti] &lt; size[rootj]) &#123;</span><br><span class="line">            parent[rooti] =  rootj;</span><br><span class="line">            size[rootj] += size[rooti];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootj] =  rooti;</span><br><span class="line">            size[rooti] += size[rootj];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>练习  </p>
<ul>
<li>「力扣」第 547 题：省份数量（中等）；</li>
<li>「力扣」第 684 题：冗余连接（中等）；</li>
<li>「力扣」第 1319 题：连通网络的操作次数（中等）；</li>
<li>「力扣」第 1631 题：最小体力消耗路径（中等）； <strong>思路</strong></li>
<li>「力扣」第 959 题：由斜杠划分区域（中等）；</li>
<li>「力扣」第 1202 题：交换字符串中的元素（中等）；</li>
<li>「力扣」第 947 题：移除最多的同行或同列石头（中等）；</li>
<li>「力扣」第 721 题：账户合并（中等）；</li>
<li>「力扣」第 803 题：打砖块（困难）；</li>
<li>「力扣」第 1579 题：保证图可完全遍历（困难）;</li>
<li>「力扣」第 778 题：水位上升的泳池中游泳（困难）。</li>
</ul>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/07/Dynamic%20Programming/">动态规划 解题思路以及常见类型归纳总结</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T16:00:00.000Z" itemprop="datePublished">
    2021-07-07
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划Dynamic Programming</strong>是运筹学的一个分支，是求解决策过程最优化的过程。各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而产生许多策略供选取。多阶段决策问题，就是要在可以选择的策略中，选取一个最优策略，使在预定的标准下达到最好的效果。</p>
<p><strong>求解动态规划的核心问题是穷举</strong>。不过，动态规划相比于暴力穷举/回溯算法，消除了重叠子问题，因此更快。可以看作是穷举+剪枝的结合。</p>
<p>动态规划的三个特点：</p>
<ul>
<li>存在重叠子问题</li>
<li>具备“最优子结构”</li>
<li>存在状态转移方程</li>
</ul>
<hr>
<h2 id="一般的解题思路"><a href="#一般的解题思路" class="headerlink" title="一般的解题思路"></a>一般的解题思路</h2><p>在解决动态规划问题时，一定要思考以下问题：</p>
<ol>
<li>问题的最简单情况base case是什么？</li>
<li>问题一共有什么状态？</li>
<li>每个状态可以做出什么选择？</li>
<li>如何定义函数来表现状态和选择？</li>
</ol>
<p><strong>基本的DP思路</strong></p>
<ol>
<li>一般使用DP Table来记录子问题的最优决策。首先要定义<code>dp[i][j]</code>，一般<code>dp[M][N]</code>会是题目所求的答案。同时注意dp的边界问题；</li>
<li>定义Base Case。 一般是<code>dp[0][0]</code>或者是<code>dp[0][...], dp[...][0]</code>；</li>
<li>寻找<code>dp[i][j]</code>的状态转移方程。 考虑一下到达<code>dp[i][j]</code>的上一步操作是什么，一般从<code>dp[i][j-1], dp[i-1][j], dp[i-1][j-1]</code>入手。</li>
</ol>
<p>进阶思路：</p>
<ol>
<li>最优子结构性值作为动态规划问题的必要条件，一定是求最值；</li>
<li>dp数组的遍历方向。有时是正向遍历，有时是反向遍历，有时是斜向遍历。<strong>遍历过程中，所需的状态是必须已经计算出来的；而且遍历终点必须是存储结果的位置</strong>。因此，遍历的方向应该是从base case到所求答案的方向。典型例子：174. Dungeon Game 反向遍历。</li>
</ol>
<hr>
<h2 id="常见的动态规划类型"><a href="#常见的动态规划类型" class="headerlink" title="常见的动态规划类型"></a>常见的动态规划类型</h2><ol>
<li>单数组的子序列问题 如: Longest Palindrome Subsequence/Substring</li>
<li>双数组的比较问题 如: Edit Distance, Longest Common Subsequence</li>
<li>二维矩阵的最值 如: Unique Paths I/II</li>
<li>Fibonacci类的递推问题 如: House Robber, Jump Game</li>
<li>背包问题 如: Target Sum</li>
</ol>
<p>无论什么类型，DP无非要解决三个问题：<strong>dp状态定义，Base Case，状态转移方程</strong></p>
<hr>
<h2 id="经典动态规划：子序列问题"><a href="#经典动态规划：子序列问题" class="headerlink" title="经典动态规划：子序列问题"></a>经典动态规划：子序列问题</h2><p>以<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-subsequence/">516. Longest Palindromic Subsequence/Medium</a>为例。</p>
<ul>
<li><code>dp[i][j]</code>定义为字符串<code>s[i:j]</code>的最长回文子序列长度（或其他答案）；</li>
<li>Base Case是<code>dp[k][k] = 1</code>；</li>
<li>状态转移：<code>dp[i][j]</code>从<code>dp[i+1][j-1]</code>，或者<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>中求得；</li>
<li>最终所求为<code>dp[0][n-1]</code>.</li>
</ul>
<p>注意这类题目的遍历方向，从<code>dp[i][i]</code>出发到<code>dp[0][n-1]</code>，方向应该是从下到上、从左到右。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">length</span>(), pre, tmp;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = len - 1; i &gt;= 0; i--)&#123;</span></span><br><span class="line"><span class="comment">        dp[i][i] = 1;</span></span><br><span class="line"><span class="comment">        for (int j = i + 1; j &lt; len; j++) &#123;</span></span><br><span class="line"><span class="comment">            if (s[i] == s[j])</span></span><br><span class="line"><span class="comment">                dp[i][j] = 2 + dp[i+1][j-1];</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return dp[0][len-1];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        pre = <span class="number">0</span>; <span class="comment">// pre = dp[i+1][j-1];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            tmp = dp[j]; <span class="comment">// tmp = dp[i+1][j]</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == s[i]) </span><br><span class="line">                dp[j] = pre + <span class="number">2</span>;     </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j<span class="number">-1</span>]);   </span><br><span class="line">            pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他同框架的题目：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. Minimum Insertion Steps to Make a String Palindrome/Hard</a>  </li>
</ul>
<p>To do:   </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/">647. Palindrome Substring/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-palindrome/">214. Shortest Palindrome/Hard</a> KMP算法</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-palindrome/">336. Palindrome pair/Hard</a> Trie 字典树/单词查找树</li>
</ul>
<hr>
<p>(以下解题思路待更新)</p>
<h2 id="经典动态规划：双数组的比较问题"><a href="#经典动态规划：双数组的比较问题" class="headerlink" title="经典动态规划：双数组的比较问题"></a>经典动态规划：双数组的比较问题</h2><p>有代表性的两题：  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/">72. Edit Distance/Hard</a>  </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence/Medium</a></li>
</ul>
<p>挑战性</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/wildcard-matching/">44. Wildcard Matching/Hard</a>  </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/511529153/">87. Scramble String/Hard 记录多状态</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/distinct-subsequences/">115. Distinct Subsequences/Hard 确定状态转移</a></li>
</ul>
<p>基础</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/interleaving-string/submissions/">97. Interleaving String/Medium</a></li>
</ul>
<hr>
<h2 id="经典动态规划：二维矩阵的最值"><a href="#经典动态规划：二维矩阵的最值" class="headerlink" title="经典动态规划：二维矩阵的最值"></a>经典动态规划：二维矩阵的最值</h2><p>求路径：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">62. Unique Paths/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">64. Minimum Path Sum/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/">120. Triangle/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/dungeon-game/">174. Dungeon Game/Hard</a> 逆向推导</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/out-of-boundary-paths/">576. Out of Boundary Paths/Medium</a></li>
</ul>
<p>求矩阵：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">42. Trapping Rain Water/Hard</a> 经典接雨水</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. Max Sum of Rectangle No Larger Than K/Hard</a> 枚举上下边界+前缀和</li>
</ul>
<hr>
<h2 id="经典动态规划：递推类"><a href="#经典动态规划：递推类" class="headerlink" title="经典动态规划：递推类"></a>经典动态规划：递推类</h2><p>这里选择一些比较有意思的系列题目进行分类。</p>
<p>House Robber</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">198. House Robber/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-iii/">337. House Robber III/Medium</a></li>
</ul>
<p>Jump Game  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">55. Jump Game/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">45. Jump Game II/Medium</a></li>
</ul>
<p>Best Time to Buy and Sell Stock</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock/Easy</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II/Easy</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">123. Best Time to Buy and Sell Stock III/Hard</a></li>
</ul>
<p>Regular Expression Matching 正则表达式匹配</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/regular-expression-matching/">10. Regular Expression Matching/Hard</a></li>
</ul>
<p>Egg Drop 过于经典，牢记</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/super-egg-drop/">887. Super Egg Drop/Hard</a></li>
</ul>
<p>LIS 最长递增子序列，DP很直观，但是二分搜索效率高很多</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/russian-doll-envelopes/">354. Russian Doll Envelopes/Hard</a></li>
</ul>
<p>其他基础：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs/Easy</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">91. Decode Ways/Medium</a> </li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees/Medium</a> 数学归纳</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">95. Unique Binary Search Trees II/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray/Medium</a> 分别存储最大最小值以应对乘积变大/变小</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/515928702/">279. Perfect Squares/Medium</a> BFS/DP均可</li>
</ul>
<hr>
<h2 id="经典动态规划：背包问题"><a href="#经典动态规划：背包问题" class="headerlink" title="经典动态规划：背包问题"></a>经典动态规划：背包问题</h2><p>背包问题的特点：取或不取。由于太过经典且重要，另开一篇。</p>
<p><strong>01背包问题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/">494. Target Sum/Medium</a> Same as 416</li>
</ul>
<p>Word Break</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/">139. Word Break/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break-ii/">140. Word Break II/Hard</a></li>
</ul>
<p><strong>完全背包问题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV/Medium</a></li>
</ul>
<p>Coin Change </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/submissions/">322. Coin Change/Medium</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change-2/">518. Coin Change 2/Medium</a></li>
</ul>
<hr>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2021/07/06/hello-world/">Hello World</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2021-07-06T15:59:20.467Z" itemprop="datePublished">
    2021-07-06
  </time>
  
  
</div>

    </header>
    <div>
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2021 - Weihong Xie </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>