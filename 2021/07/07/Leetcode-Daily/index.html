<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Record of daily Leetcode | Weihong Xie&#39;s Blogs</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/bg.jpg)">
        <div class='av-pic' style="background-image: url(/assets/Bella.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Weihong Xie&#39;s Blogs</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/WeihongXie">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Record of daily Leetcode</h1>
    </header>

    <section>
      <p>刷题技巧：<br>数据结构的基本存储方式：链式，顺序；<br>数据结构的操作方式：增删查改；<br>数据结构的遍历方式：迭代，递归  </p>
<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a><strong>Binary Tree</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// preorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.left);</span><br><span class="line">    <span class="comment">// inorder</span></span><br><span class="line">    <span class="built_in">traverse</span>(root.right);</span><br><span class="line">    <span class="comment">// postorder</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代版本，使用Stack存储节点</span></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    cout &lt;&lt; current-&gt;val;</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right) </span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (current <span class="keyword">or</span> !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(current);</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 栈顶元素是最左节点</span></span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>()-&gt;val;</span><br><span class="line">        current = stack.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line">stack.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* current = stack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        stack.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目：</p>
<ul>
<li><strong>102_medium: level order</strong></li>
<li><strong>103_medium: zigzag level order</strong></li>
<li><strong>105_medium: pre&amp;in construct</strong></li>
<li><strong>106_medium: in&amp;post construct</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 102 level order</span></span><br><span class="line"><span class="comment">// 使用队列FIFO的特性实现层次遍历，每次push队首的左右子节点，pop</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; layer_seq;</span><br><span class="line">        layer_seq.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; root_seq = <span class="built_in">vector</span>(<span class="number">1</span>, root-&gt;val);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root_seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!layer_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node_num = layer_seq.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;node_num; i++) &#123;                </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;left) &#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;left-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                <span class="keyword">if</span> (layer_seq.<span class="built_in">front</span>()-&gt;right)&#123;</span><br><span class="line">                    layer_seq.<span class="built_in">push</span>(layer_seq.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                    seq.<span class="built_in">push_back</span>(layer_seq.<span class="built_in">front</span>()-&gt;right-&gt;val);</span><br><span class="line">                &#125;                    </span><br><span class="line">                layer_seq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!seq.<span class="built_in">empty</span>()) </span><br><span class="line">                res.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 103 use dequeue</span></span><br></pre></td></tr></table></figure>


<p>递归问题基本可以代入为树的问题</p>
<p>Solved:</p>
<ul>
<li><strong>124_Hard: find max path using postorder</strong></li>
</ul>
<h2 id="关于Binary-Tree的经典问题"><a href="#关于Binary-Tree的经典问题" class="headerlink" title="关于Binary Tree的经典问题"></a>关于Binary Tree的经典问题</h2><h2 id="1-最近公共祖先-LowestCommonAncestor"><a href="#1-最近公共祖先-LowestCommonAncestor" class="headerlink" title="1. 最近公共祖先 LowestCommonAncestor"></a><strong>1. 最近公共祖先 LowestCommonAncestor</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) <span class="comment">// one in left tree, other in right tree</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Binary-Search-Tree"><a href="#2-Binary-Search-Tree" class="headerlink" title="2. Binary Search Tree"></a><strong>2. Binary Search Tree</strong></h2><p>二叉搜索树的中序遍历 = 树节点从小到大遍历</p>
<h2 id="3-Balanced-Binary-Tree"><a href="#3-Balanced-Binary-Tree" class="headerlink" title="3. Balanced Binary Tree"></a><strong>3. Balanced Binary Tree</strong></h2><hr>
<h2 id="Dynamic-Programming-动态规划"><a href="#Dynamic-Programming-动态规划" class="headerlink" title="Dynamic Programming 动态规划"></a><strong>Dynamic Programming 动态规划</strong></h2><p>动态规划相比于暴力穷举/回溯算法，消除了重叠子问题，因此更快。可以看作是穷举+剪枝的结合。（通过哈希表作为备忘录，也可以消除重叠子问题的计算）</p>
<p>动态规划的三个特点：</p>
<ul>
<li>求最值；</li>
<li>求子问题的最值（-&gt;状态转移）；</li>
<li>存在重叠子问题；</li>
</ul>
<p>做题思路：</p>
<ol>
<li>问题的最简单情况base case是什么？</li>
<li>问题一共有什么状态？</li>
<li>每个状态可以做出什么选择？</li>
<li>如何定义函数来表现状态和选择？</li>
</ol>
<p>动态规划是“自下而上”的。从最简单、规模最小的问题如<code>f(1),f(2)</code>往上推。一般是由循环迭代完成计算的。</p>
<p><strong>基本的DP思路</strong></p>
<ol>
<li>定义<code>dp[i][j]</code>的含义，一般<code>dp[M][N]</code>会是题目所求的答案。同时注意dp的边界问题；</li>
<li>定义Base Case。 一般是<code>dp[0][0]</code>或者是<code>dp[0][...], dp[...][0]</code>；</li>
<li>寻找<code>dp[i][j]</code>的状态转移方程。 考虑一下到达<code>dp[i][j]</code>的上一步操作是什么，一般从<code>dp[i][j-1], dp[i-1][j], dp[i-1][j-1]</code>入手。</li>
</ol>
<p>进阶思路：</p>
<ol>
<li>最优子结构性值作为动态规划问题的必要条件，一定是求最值；</li>
<li>dp数组的遍历方向。有时是正向遍历，有时是反向遍历，有时是斜向遍历。<strong>遍历过程中，所需的状态是必须已经计算出来的；而且遍历终点必须是存储结果的位置</strong>。典型例子：Dungeon Game 反向遍历。</li>
</ol>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>将问题分到以下一类动态规划问题中：</p>
<ol>
<li>0-1 Knapsack 选/不选</li>
<li>Unbounded Knapsack 完全背包 不限数量的选/不选</li>
<li>Shortest Path (eg: Unique Paths I/II) 二维矩阵路径选择</li>
<li>Fibonacci Sequence (eg: House Thief, Jump Game) 一维矩阵，每个元素由前面元素决定</li>
<li>Longest Common Substring/Subsequence 双数组/字符串的比较</li>
</ol>
<h3 id="经典动态规划：01背包问题"><a href="#经典动态规划：01背包问题" class="headerlink" title="经典动态规划：01背包问题"></a><strong>经典动态规划：01背包问题</strong></h3><p>一个可装载重量<code>W</code>的背包，一共有<code>N</code>个物品，每个物品有重量<code>wt[i]</code>和价值<code>val[i]</code>两个属性。物品不可以分割，要么选择，要么不选择，称为01背包问题。这类问题没有排序之类的方法，只能穷举所有可能。</p>
<p>定义<code>dp[i][w]</code>：对于前<code>i</code>个物品，当前背包容量为<code>w</code>，对应的最大价值。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backpack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt;&amp; weight, vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w - weight[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w - weight[i]] + val[i - <span class="number">1</span>], dp[i - <span class="number">1</span>][w])；</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Backtracking-回溯算法"><a href="#Backtracking-回溯算法" class="headerlink" title="Backtracking 回溯算法"></a><strong>Backtracking 回溯算法</strong></h2><p>回溯，既纯暴力穷举，复杂度很高。如同多叉树的前序遍历/后序遍历。</p>
<p>思路：</p>
<ol>
<li>路径：已经做出的选择；</li>
<li>选择列表：当前可以做的选择；</li>
<li>结束条件：到达决策树底层的条件。</li>
</ol>
<p>核心：for循环里进行递归，递归前“做选择”，递归结束后“撤回选择”，直到结束。</p>
<p>算法框架</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">path, choices</span>):</span></span><br><span class="line">    <span class="keyword">if</span> condition_satisfied:</span><br><span class="line">        result.add(path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> choices:</span><br><span class="line">        makeChoice(choice);</span><br><span class="line">        backtrack(path, choices);</span><br><span class="line">        backdrawChoice(choice);</span><br></pre></td></tr></table></figure>

<p>See <strong>N Queens</strong></p>
<hr>
<h2 id="Breath-First-Search-广度优先算法"><a href="#Breath-First-Search-广度优先算法" class="headerlink" title="Breath First Search 广度优先算法"></a><strong>Breath First Search 广度优先算法</strong></h2><p>DFS(Depth First Search)深度优先搜索算法可以被认为回溯算法。</p>
<p>BFS和DFS最大差别：<strong>BFS找到的路径一定最短，但是代价是空间复杂度比DFS大很多。</strong></p>
<p>BFS问题本质：在图中找到从起点<code>start</code>到终点<code>target</code>的最短距离。比如走迷宫、二叉树最小高度。</p>
<p>算法框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(TreeNode start, TreeNode target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q;</span><br><span class="line">    Set&lt;TreeNode&gt; visited;  <span class="comment">// 已经过的路径</span></span><br><span class="line"></span><br><span class="line">    q.offer(start);</span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="comment">// 判断是否终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">// 加入之后的选择路径</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode x: cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bidirectional-BFS-双向BFS"><a href="#Bidirectional-BFS-双向BFS" class="headerlink" title="Bidirectional BFS 双向BFS"></a><strong>Bidirectional BFS 双向BFS</strong></h3><p>从起点<code>start</code>和终点<code>target</code>同时出发遍历。<br>不再使用队列<code>queue</code>作为主要数据结构，而是使用<code>unordered_set</code>方便、快速地判断两个集合是否有交集。<br><strong>Leetcode: WordLadder I &amp;&amp; II</strong></p>
<hr>
<h2 id="Two-Pointer-双指针"><a href="#Two-Pointer-双指针" class="headerlink" title="Two Pointer 双指针"></a><strong>Two Pointer 双指针</strong></h2><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h3><p>常用于链表之中，如</p>
<ol>
<li><strong>链表中存在环的问题</strong>（fast=-&gt;next-&gt;next, slow=-&gt;next）；</li>
<li><strong>查找链表中点</strong>（fast到头时返回slow）</li>
<li><strong>寻找链表中倒数第K元素</strong>；</li>
</ol>
<h3 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h3><p>常用于数组之中。一般初始化为<code>left = 0</code>，<code>right = len - 1</code>。</p>
<p>应用：</p>
<ol>
<li><strong>二分搜索 Binary Search</strong></li>
<li><strong>滑动窗口 Sliding Window</strong>，解决字符串匹配问题</li>
</ol>
<hr>
<h2 id="Binary-Search-二分搜索"><a href="#Binary-Search-二分搜索" class="headerlink" title="Binary Search 二分搜索"></a><strong>Binary Search 二分搜索</strong></h2><p>细节难点：mid+1还是mid-1，while用&lt;=还是&lt;等。<br>技巧：使用if的时候不要使用else，将所用情况用else if写清楚。 </p>
<p><strong>基本二分搜索：在递增序列中，寻找一个数字</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定循环终止条件<br><code>left &lt;= right</code>的终止条件是<code>left &gt; right</code>即<code>left == right + 1</code>。将整个区间[left, right]搜索完毕。</li>
<li><code>left</code>,<code>right</code>的变更形式<br>当搜索区间[left, right]的时候，如果<code>mid</code>不符合<code>target</code>条件，下一步应该考虑区间要不要包含mid，不需要则是<code>mid+1/mid-1</code>，需要则是<code>mid</code></li>
</ol>
<p><strong>带左边界的二分搜索</strong><br>终止条件：<code>left == right + 1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) &gt;&gt; <span class="number">1</span>; <span class="comment">// 防溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 继续往左;右边界：left = mid + 1;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (right &lt; 0 || nums[right] != target)</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">    return right;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a><strong>Sliding Window 滑动窗口</strong></h2><p>框架  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: t)</span><br><span class="line">        need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// Expand the window</span></span><br><span class="line">        <span class="built_in">window</span>(s[right])++;</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">valid</span>(window, need)) &#123;</span><br><span class="line">            <span class="comment">// Narrow the window</span></span><br><span class="line">            <span class="built_in">window</span>(s[left])--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Union-Find-并查集"><a href="#Union-Find-并查集" class="headerlink" title="Union Find 并查集"></a><strong>Union Find 并查集</strong></h2><p>并查集算法，主要是解决图论中<strong>动态连通性</strong>的问题。</p>
<p>框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; size; <span class="comment">// 用于调整树的高度，避免头重脚轻(不重要)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent.<span class="built_in">push_back</span>(i);</span><br><span class="line">            size.<span class="built_in">push_back</span>(i); <span class="comment">// each tree is initialized with size 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x])</span><br><span class="line">            parent[x] = <span class="built_in">find</span>(parent[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rooti = <span class="built_in">find</span>(i), rootj = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (rooti == rootj)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// or simply parent[rooti] = rootj;</span></span><br><span class="line">        <span class="keyword">if</span> (size[rooti] &lt; size[rootj]) &#123;</span><br><span class="line">            parent[rooti] =  rootj;</span><br><span class="line">            size[rootj] += size[rooti];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootj] =  rooti;</span><br><span class="line">            size[rooti] += size[rootj];</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>练习  </p>
<ul>
<li>「力扣」第 547 题：省份数量（中等）；</li>
<li>「力扣」第 684 题：冗余连接（中等）；</li>
<li>「力扣」第 1319 题：连通网络的操作次数（中等）；</li>
<li>「力扣」第 1631 题：最小体力消耗路径（中等）； <strong>思路</strong></li>
<li>「力扣」第 959 题：由斜杠划分区域（中等）；</li>
<li>「力扣」第 1202 题：交换字符串中的元素（中等）；</li>
<li>「力扣」第 947 题：移除最多的同行或同列石头（中等）；</li>
<li>「力扣」第 721 题：账户合并（中等）；</li>
<li>「力扣」第 803 题：打砖块（困难）；</li>
<li>「力扣」第 1579 题：保证图可完全遍历（困难）;</li>
<li>「力扣」第 778 题：水位上升的泳池中游泳（困难）。</li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2021-07-06T16:49:38.951Z" itemprop="datePublished">
              2021-07-07
            </time>
          </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2021 - Weihong Xie </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>